#!/usr/bin/python

import os
import sys
import requests
import json
from bs4 import BeautifulSoup

TIER = ["Bronze", "Silver", "Gold", "Platinum", "Diamond", "Ruby"]
RANK = ["I", "II", "III", "IV", "V"]
TYPES = [("description", "문제 설명"), ("input", "입력"),
         ("output", "출력"), ("limit", "제한")]


def get_info(id: int) -> str:
    result = {}
    url = f"https://www.acmicpc.net/problem/{id}"
    headers = {
        "user-agent": "Mozilla/5.0 (Windows NT 10.0Win64x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36"
    }
    response = requests.get(url, headers=headers)
    html = response.text
    soup = BeautifulSoup(html, 'html.parser')
    for type in TYPES:
        div_tag = soup.select_one(
            f"#problem_{type[0]}").find_all(recursive=False)
        result[type[0]] = [str(tag) for tag in div_tag]
    return result


def make_readme_text(id: int, title: str, tier: str, rank: int, tag_list: list) -> str:
    result = ""

    def insert(content: str):
        nonlocal result
        result += content
        result += "\n\n"
    insert(f"# [{tier} {RANK[rank-1]}] {title}")
    insert(f"[문제 링크](https://www.acmicpc.net/problem/{id})")
    insert(f"### 성능 요약")
    insert(f"### 분류")
    tags = [f"{tag[0]}({tag[1]})" for tag in tag_list]
    insert(". ".join(tags))

    info = get_info(id=id)
    for type in TYPES:
        if info[type[0]]:
            insert(f"### {type[1]}")
            for detail in info[type[0]]:
                insert(detail)

    return result


def get_problem(num: int) -> dict:
    url = "https://solved.ac/api/v3/problem/show"

    headers = {"Content-Type": "application/json"}

    params = {"problemId": num}

    response = requests.get(url, headers=headers, params=params)
    return response.json()


def get_level_data(level: int) -> tuple[str, int]:

    if level == 0:
        return "Unrated", 0
    tier = TIER[(level-1)//5]
    rank = (level-1) % 5
    return tier, rank


def make_all(problem_id: int):
    data = get_problem(problem_id)
    id: int = data.get("problemId", 00000)
    title: str = data.get("titleKo", "title")
    level: int = data.get("level", 0)
    tags = data['tags']

    tag_name_list = [tag["displayNames"] for tag in tags]
    tag_list = []
    for names in tag_name_list:
        ko = "no result"
        en = "no result"
        for name in names:
            if name["language"] == "ko":
                ko = name["name"]
            if name["language"] == "en":
                en = name["name"]
        tag_list = [*tag_list, [ko, en]]

    # make dir
    def make_dir(dir: str) -> bool:
        if os.path.isdir(dir):
            print(f"{dir} is exist")
            return False
        else:
            os.makedirs(dir)
            return True
    tier, rank = get_level_data(level=level)
    tier_dir = os.path.join(boj_path, tier)
    make_dir(tier_dir)
    pro_dir_name = f"{rank}-{id}. {title}"
    pro_dir = os.path.join(tier_dir, pro_dir_name)
    if (not make_dir(pro_dir)):
        user_in = input(f"덮어쓰시겠습니까?(a.cpp 파일은 덮어쓰지 않습니다.) (Y/N): ")
        if user_in not in ["y", "Y", "yes", "YES"]:
            print("생성을 취소합니다.")
            exit(1)

    readme_path = os.path.join(pro_dir, "README.md")
    cfile_path = os.path.join(pro_dir, "a.cpp")
    data_path = os.path.join(pro_dir, "testdata")
    readme_text = make_readme_text(
        id=id, title=title, tier=tier, rank=rank, tag_list=tag_list)
    with open(readme_path, "w") as fp:
        fp.write(readme_text)
    with open(cfile_path, "a") as fp:
        pass
    with open(data_path, "w") as fp:
        pass


if __name__ == "__main__":
    if len(sys.argv) == 2:
        pro_num = int(sys.argv[1])
    else:
        print("usage: makeboj [pro_num]")
        exit(1)

    now_path = os.getcwd()
    if now_path.split("/")[-1] == "baekjoon":
        boj_path = now_path
    else:
        boj_path = os.path.join(now_path, "baekjoon")

    if not os.path.isdir(boj_path):
        print("directory is not found")
        print("baekjoon 디렉토리 내/외 부에서 실행 해 주세요")
        exit(1)

    make_all(pro_num)
